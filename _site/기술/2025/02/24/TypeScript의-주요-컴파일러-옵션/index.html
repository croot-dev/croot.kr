<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>TypeScript의 주요 컴파일러 옵션 - Croot Blog</title>
  <meta name="description" content="importsNotUsedAsValues, preserveValueImports, isolatedModules, verbatimModuleSyntax의 등장 순서와 의미">
  <link href='https://fonts.googleapis.com/css?family=Roboto+Mono|Roboto:300,400,900,400italic' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://localhost:4000/%EA%B8%B0%EC%88%A0/2025/02/24/TypeScript%EC%9D%98-%EC%A3%BC%EC%9A%94-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EC%98%B5%EC%85%98/">
  <link rel="alternate" type="application/rss+xml" title="Croot Blog" href="http://localhost:4000/feed.xml">
</head>

  <body>
    <aside class="c-page__searchbox">
  <div class="search">
    <input id="search-input" 
      type="search" 
      tabindex="1" 
      spellcheck="false" 
      placeholder="검색어"
    />
  </div>

  <ul id="results-container"></ul>
</aside>

<script src="/assets//script/simple-jekyll-search.min.js"></script>
<script type="text/javascript">
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('results-container'),
    json: '/assets/json/search.json',
    noResultText: '검색결과가 없습니다.',
    limit: 1000,
    fuzzy: false
  })
</script>

    <main class="u-container">
      <div class="c-page">
  <header class="c-page__header">
  <h1><code>Croot Blog</code></h1>
  
  <p>
    <a href="/">Home</a>
    <span class="u-separate"></span>
    <a href="/about/">About</a>
    <span class="u-separate"></span>
    <a href="/tech/">Tech</a>
    <span class="u-separate"></span>
    <a href="/hobby/">Hobby</a>
    <span class="u-separate"></span>
    <a href="/archive/">Archive</a>
  </p>
</header>

  <div class="c-page__main">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '\\[', right: '\\]', display: true}
          ],
          throwOnError : false
        });
    });
</script>

<div>

<div style="display:flex;flex-direction:row;background:#efefef;padding: 1.2em 1.5em;">
  <span style="width:70px;font-size:2.8em">⚠️</span>
  <p style="flex:1;font-size:1.2em;line-height: 1.5;word-break: keep-all;">
    <span>이 블로그의 모든 포스트는 Notion 데이터베이스를 자동 변환하여 작성 되었습니다.</span><br />
    <span>따라서 문서에 따라 깨져 보일 수 있습니다.</span><br />
    <span>더 많은 내용이 궁금하시다면 👀</span> <a href="https://www.notion.so/croot-dev/6c50e956396b41449b42a8e134d97c4e" target="_blank" style="margin-top:12px;z-index:1">Notion 보러가기</a>
  </p>
</div>

</div>

<article class="c-article">
  <header class="c-article__header">
    <h1 class="c-article__title">TypeScript의 주요 컴파일러 옵션</h1>
    <!-- <p class="c-article__time"><time datetime="2025-02-24T00:00:00+09:00" itemprop="datePublished">Feb 24, 2025</time></p> -->
  </header>

  <div class="c-article__info">
    <table>
      <tbody>
        <tr>
          <th>작성일</th><td>2025년 02월 24일</td>
        </tr>
        <tr>
          <th>수정일</th><td>2025년 03월 21일</td>
        </tr>
        <tr>
          <th>카테고리</th><td>기술</td>
        </tr>
        <tr>
          <th>태그</th><td>
            <ul class="c-tags">
              
            </ul>
          </td>
        </tr>
        
        <tr>
          <th>원본</th><td><a href="https://croot.notion.site/1a46063e6590802ca0d3cd74f7247aba" target="_blank" rel="noopener noreferrer">https://croot.notion.site/1a46063e6590802ca0d3cd74f7247aba</a></td>
        </tr>
        
      </tbody>
    </table>
  </div>

  <div class="c-article__main">
    <h1 id="importsnotusedasvalues-preservevalueimports-isolatedmodules-verbatimmodulesyntax의-등장-순서와-의미"><code class="language-plaintext highlighter-rouge">importsNotUsedAsValues</code>, <code class="language-plaintext highlighter-rouge">preserveValueImports</code>, <code class="language-plaintext highlighter-rouge">isolatedModules</code>, <code class="language-plaintext highlighter-rouge">verbatimModuleSyntax</code>의 등장 순서와 의미</h1>

<p>TypeScript는 다양한 컴파일러 옵션을 통해 개발자가 코드의 빌드 및 트랜스파일 방식을 세밀하게 제어할 수 있도록 해줍니다. 그중에서도 <strong><code class="language-plaintext highlighter-rouge">importsNotUsedAsValues</code></strong>, <strong><code class="language-plaintext highlighter-rouge">preserveValueImports</code></strong>, <strong><code class="language-plaintext highlighter-rouge">isolatedModules</code></strong>, <strong><code class="language-plaintext highlighter-rouge">verbatimModuleSyntax</code></strong>와 같은 옵션들은 JavaScript로 변환될 때의 <strong>타입 처리 및 모듈 변환</strong> 방식에 큰 영향을 미칩니다. 이 옵션들이 어떻게 등장했는지, 각각의 필요성과 설정 방법, 그리고 옵션들 간의 관계에 대해 알아보겠습니다.</p>

<hr />

<h2 id="1-isolatedmodules-typescript-37">1. <code class="language-plaintext highlighter-rouge">isolatedModules</code> (TypeScript 3.7)</h2>

<h3 id="-도입-시기-typescript-37">📅 <strong>도입 시기: TypeScript 3.7</strong></h3>

<p>TypeScript 3.7에서 처음 도입된 <code class="language-plaintext highlighter-rouge">isolatedModules</code> 옵션은 TypeScript 컴파일러가 <strong>모든 모듈을 독립적으로 처리하도록 강제</strong>하는 역할을 합니다. 이는 특히 <strong>Babel, esbuild, SWC와 같은 트랜스파일러</strong>와 함께 사용할 때 중요한 역할을 하며, 개별 파일을 트랜스파일할 수 있도록 설정해 줍니다.</p>

<h3 id="-필요성">🎯 <strong>필요성</strong></h3>

<p><code class="language-plaintext highlighter-rouge">isolatedModules</code>가 활성화되면 TypeScript는 <strong>각각의 파일을 독립적으로 컴파일</strong>하도록 강제합니다. 트랜스파일러가 파일 간 종속성을 처리할 수 없을 경우, 이 옵션을 사용해야 합니다. <code class="language-plaintext highlighter-rouge">isolatedModules</code>를 설정하면 <strong><code class="language-plaintext highlighter-rouge">const enum</code></strong>과 같은 일부 TypeScript 특성이 지원되지 않지만, <strong>Babel과 같은 트랜스파일러와의 호환성</strong>을 보장할 수 있습니다.</p>

<h3 id="️-설정값">⚙️ <strong>설정값</strong></h3>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"isolatedModules"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span><span class="p">}</span><span class="w">

</span></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">true</code>: <strong>모든 파일을 개별적으로 트랜스파일</strong>합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">false</code>: <strong>파일 간 종속성도 고려하여 트랜스파일</strong>합니다 (기본값).</li>
</ul>

<hr />

<h2 id="2-importsnotusedasvalues-typescript-38">2. <code class="language-plaintext highlighter-rouge">importsNotUsedAsValues</code> (TypeScript 3.8)</h2>

<h3 id="-도입-시기-typescript-38">📅 <strong>도입 시기: TypeScript 3.8</strong></h3>

<p><code class="language-plaintext highlighter-rouge">importsNotUsedAsValues</code> 옵션은 <strong>타입 전용 import</strong>가 JavaScript로 변환될 때 어떻게 처리될지를 결정하는 옵션입니다. TypeScript에서 <code class="language-plaintext highlighter-rouge">import type</code>을 사용하면 <strong>타입만 가져오고 실제 코드에는 영향을 미치지 않기 때문에</strong> 이를 처리하는 방법을 설정할 수 있게 되었습니다.</p>

<h3 id="-필요성-1">🎯 <strong>필요성</strong></h3>

<p>이 옵션은 TypeScript 코드에서 <strong>타입만 가져오는 import가 최종 JavaScript 코드에 영향을 미칠지 여부</strong>를 결정할 수 있게 해줍니다. 예를 들어, <code class="language-plaintext highlighter-rouge">import type</code>으로 가져온 타입이 사용되지 않으면 이를 <strong>제거할지, 유지할지</strong> 선택할 수 있습니다.</p>

<h3 id="️-설정값-1">⚙️ <strong>설정값</strong></h3>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"importsNotUsedAsValues"</span><span class="p">:</span><span class="w"> </span><span class="s2">"remove"</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="s2">"preserve"</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="s2">"error"</span><span class="w">
</span><span class="p">}</span><span class="w">

</span></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">remove</code>: (기본값) <strong>사용되지 않는 타입 import를 제거</strong>합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">preserve</code>: <strong>사용되지 않는 타입 import도 유지</strong>합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">error</code>: <strong>타입 import가 있으면 오류를 발생</strong>시킵니다.</li>
</ul>

<hr />

<h2 id="3-preservevalueimports-typescript-45">3. <code class="language-plaintext highlighter-rouge">preserveValueImports</code> (TypeScript 4.5)</h2>

<h3 id="-도입-시기-typescript-45">📅 <strong>도입 시기: TypeScript 4.5</strong></h3>

<p><code class="language-plaintext highlighter-rouge">preserveValueImports</code> 옵션은 <code class="language-plaintext highlighter-rouge">importsNotUsedAsValues</code>와 비슷하지만, <strong>값 기반 import에 대해서도 영향을 미칩니다</strong>. 이 옵션은 사용되지 않는 값 import를 <strong>유지할지 제거할지</strong> 설정할 수 있습니다.</p>

<h3 id="-필요성-2">🎯 <strong>필요성</strong></h3>

<p>이 옵션은 <strong>값 import와 타입 import</strong> 모두에 영향을 미칩니다. <code class="language-plaintext highlighter-rouge">preserveValueImports: true</code>로 설정하면, <strong>값으로 사용하는</strong> <strong><code class="language-plaintext highlighter-rouge">import</code></strong><strong>도 코드에서 제거되지 않도록</strong> 유지할 수 있습니다. 이는 <strong>트리 셰이킹</strong>을 조정하거나, 값 기반 import를 유지해야 하는 경우 유용합니다.</p>

<h3 id="️-설정값-2">⚙️ <strong>설정값</strong></h3>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"preserveValueImports"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span><span class="p">}</span><span class="w">

</span></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">true</code>: <strong>사용되지 않는 값 import도 제거하지 않고 유지</strong>합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">false</code>: (기본값) <strong>사용되지 않는 값 import를 제거</strong>합니다.</li>
</ul>

<hr />

<h2 id="4-verbatimmodulesyntax-typescript-50">4. <code class="language-plaintext highlighter-rouge">verbatimModuleSyntax</code> (TypeScript 5.0)</h2>

<h3 id="-도입-시기-typescript-50">📅 <strong>도입 시기: TypeScript 5.0</strong></h3>

<p><code class="language-plaintext highlighter-rouge">verbatimModuleSyntax</code> 옵션은 <strong>ESM(ECMAScript Modules) 구문을 변환하지 않고 그대로 유지</strong>하도록 하는 옵션입니다. 이 옵션은 TypeScript가 <strong><code class="language-plaintext highlighter-rouge">import</code></strong><strong>/</strong><strong><code class="language-plaintext highlighter-rouge">export</code></strong> <strong>구문을 변형하지 않고 그대로 보존</strong>할 수 있도록 해줍니다.</p>

<h3 id="-필요성-3">🎯 <strong>필요성</strong></h3>

<p><code class="language-plaintext highlighter-rouge">verbatimModuleSyntax: true</code>를 설정하면 TypeScript는 <strong>ESM 구문을 그대로 유지</strong>합니다. 이를 통해 <strong>ESM 모듈을 다른 환경에 그대로 적용</strong>할 수 있게 되며, <strong>타입 import</strong>나 <strong>값 import</strong> 모두 변환 없이 유지됩니다. 주로 <strong>ESM 환경</strong>에서 <strong>Babel, Deno, Nuxt 3</strong> 같은 최신 도구들과 함께 사용할 때 유용합니다.</p>

<h3 id="️-설정값-3">⚙️ <strong>설정값</strong></h3>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"verbatimModuleSyntax"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span><span class="p">}</span><span class="w">

</span></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">true</code>: <strong><code class="language-plaintext highlighter-rouge">import</code></strong><strong>/</strong><strong><code class="language-plaintext highlighter-rouge">export</code></strong> <strong>구문을 변환하지 않고 그대로 유지</strong>합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">false</code>: (기본값) <strong>구문 최적화 및 변환을 수행</strong>합니다.</li>
</ul>

<hr />

<h2 id="각-옵션들의-관계">각 옵션들의 관계</h2>

<h3 id="1-isolatedmodules와-verbatimmodulesyntax">1. <strong><code class="language-plaintext highlighter-rouge">isolatedModules</code></strong><strong>와</strong> <strong><code class="language-plaintext highlighter-rouge">verbatimModuleSyntax</code></strong></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">isolatedModules</code>는 각 파일을 <strong>독립적으로 트랜스파일</strong>하도록 강제하는 옵션입니다. 이 옵션을 활성화하면, TypeScript는 <strong>ESM 구문</strong>을 변환하지 않으므로 <code class="language-plaintext highlighter-rouge">verbatimModuleSyntax</code>가 유용할 수 있습니다.</li>
  <li>두 옵션은 <strong>ESM 모듈을 효율적으로 처리</strong>할 때 관련이 있습니다. <code class="language-plaintext highlighter-rouge">isolatedModules: true</code>로 설정하면 <code class="language-plaintext highlighter-rouge">verbatimModuleSyntax: true</code>를 사용하여 <strong>변환 없이 모듈을 유지</strong>할 수 있습니다.</li>
</ul>

<h3 id="2-importsnotusedasvalues와-preservevalueimports">2. <strong><code class="language-plaintext highlighter-rouge">importsNotUsedAsValues</code></strong><strong>와</strong> <strong><code class="language-plaintext highlighter-rouge">preserveValueImports</code></strong></h3>

<ul>
  <li>두 옵션은 <strong>import 처리</strong>에 관련된 옵션입니다. <code class="language-plaintext highlighter-rouge">importsNotUsedAsValues</code>는 타입 import에, <code class="language-plaintext highlighter-rouge">preserveValueImports</code>는 <strong>값 import에</strong> 영향을 미칩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">preserveValueImports</code>가 활성화되면, <strong>타입 import 외에도 값 import도 코드에서 제거되지 않도록 유지</strong>됩니다. 이는 <code class="language-plaintext highlighter-rouge">importsNotUsedAsValues: "preserve"</code>와 비슷한 역할을 합니다.</li>
</ul>

<h3 id="3-verbatimmodulesyntax와-preservevalueimports">3. <strong><code class="language-plaintext highlighter-rouge">verbatimModuleSyntax</code></strong><strong>와</strong> <strong><code class="language-plaintext highlighter-rouge">preserveValueImports</code></strong></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">verbatimModuleSyntax: true</code>는 <strong>ESM 구문</strong>을 그대로 유지하는 옵션이고, <code class="language-plaintext highlighter-rouge">preserveValueImports</code>는 <strong>import된 값을 유지</strong>하는 옵션입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">verbatimModuleSyntax</code>를 사용하면 <strong>import 구문</strong>이 그대로 유지되므로, <code class="language-plaintext highlighter-rouge">preserveValueImports</code>와 함께 사용하여 <strong>사용되지 않는 import도 제거하지 않게</strong> 설정할 수 있습니다.</li>
</ul>

<hr />

<h2 id="결론">결론</h2>

<p>TypeScript에서의 <code class="language-plaintext highlighter-rouge">isolatedModules</code>, <code class="language-plaintext highlighter-rouge">importsNotUsedAsValues</code>, <code class="language-plaintext highlighter-rouge">preserveValueImports</code>, <code class="language-plaintext highlighter-rouge">verbatimModuleSyntax</code>는 모두 <strong>모듈 시스템 및 트랜스파일</strong>과 관련된 중요한 옵션들입니다. 각각의 도입 시기와 필요성에 맞게 설정을 활용하면, <strong>ESM 환경</strong>에서 최적화된 빌드를 할 수 있습니다.</p>

<ul>
  <li><em><code class="language-plaintext highlighter-rouge">isolatedModules</code></em>는 <strong>파일 단위로 컴파일</strong>을 강제하여 <strong>Babel</strong>과 같은 도구와의 호환성을 확보합니다.</li>
  <li><em><code class="language-plaintext highlighter-rouge">importsNotUsedAsValues</code></em>는 <strong>타입 import</strong>가 코드에서 어떻게 처리될지 결정하며, <em>*<code class="language-plaintext highlighter-rouge">preserveValueImports</code></em>와 연관되어 있습니다.</li>
  <li><em><code class="language-plaintext highlighter-rouge">preserveValueImports</code></em>는 <strong>값 import</strong>까지 유지할 수 있는 설정을 제공하며, <em>*<code class="language-plaintext highlighter-rouge">verbatimModuleSyntax</code></em>는 ESM 구문을 그대로 유지하는 데 도움을 줍니다.</li>
</ul>

<p>이들 옵션은 각기 다른 환경과 상황에서 매우 중요한 역할을 하므로, <strong>ESM 모듈</strong>을 다룰 때 적절히 설정하여 최적의 결과를 얻을 수 있습니다.</p>


  </div>

  <div class="c-article__comment">
    <script src="https://utteranc.es/client.js"
        repo="croot-dev/croot-dev.github.io"
        issue-term="title"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
  </div>


  <!-- Previous / Next Buttons -->
  <div class="pagenav">
    
    <div class="wrapper" id="left">
      <small><b>Previous</b> Feb 19, 2025</small>
      <br>
      <a class="no-hov" href="/%EA%B8%B0%EC%88%A0/2025/02/19/Yarn%EC%97%90%EC%84%9C-preinstall,-postinstall,-prepare-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0/">&laquo; Yarn에서 preinstall, postinstall, prepare 스크립트 활용하기</a>
    </div>
    
    
    <div class="wrapper" id="right">
      <small>Apr 1, 2025 <b>Next</b></small>
      <br>
      <a class="no-hov" href="/%EA%B8%B0%EC%88%A0/2025/04/01/html-to-pdf/">⚠️ html to pdf &raquo;</a>
    </div>
    
  </div>
  <!-- Disqus comments view -->
  
</article>

  </div>
  <footer class="c-page__footer">
  <p>&copy; croot-dev.github.io 2026</p>
  <p><a href="https://github.com/croot-dev">Github</a></p>
</footer>

</div>

    </main>
    
  </body>
</html>
