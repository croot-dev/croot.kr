<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Clean Archtecture 서적 정리 - Croot Blog</title>
  <meta name="description" content="소개">
  <link href='https://fonts.googleapis.com/css?family=Roboto+Mono|Roboto:300,400,900,400italic' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://localhost:4000/%EC%B7%A8%EB%AF%B8/2023/12/27/Clean-Archtecture-%EC%84%9C%EC%A0%81-%EC%A0%95%EB%A6%AC/">
  <link rel="alternate" type="application/rss+xml" title="Croot Blog" href="http://localhost:4000/feed.xml">
</head>

  <body>
    <aside class="c-page__searchbox">
  <div class="search">
    <input id="search-input" 
      type="search" 
      tabindex="1" 
      spellcheck="false" 
      placeholder="검색어"
    />
  </div>

  <ul id="results-container"></ul>
</aside>

<script src="/assets//script/simple-jekyll-search.min.js"></script>
<script type="text/javascript">
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('results-container'),
    json: '/assets/json/search.json',
    noResultText: '검색결과가 없습니다.',
    limit: 1000,
    fuzzy: false
  })
</script>

    <main class="u-container">
      <div class="c-page">
  <header class="c-page__header">
  <h1><code>Croot Blog</code></h1>
  
  <p>
    <a href="/">Home</a>
    <span class="u-separate"></span>
    <a href="/about/">About</a>
    <span class="u-separate"></span>
    <a href="/tech/">Tech</a>
    <span class="u-separate"></span>
    <a href="/hobby/">Hobby</a>
    <span class="u-separate"></span>
    <a href="/archive/">Archive</a>
  </p>
</header>

  <div class="c-page__main">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '\\[', right: '\\]', display: true}
          ],
          throwOnError : false
        });
    });
</script>

<div>

<div style="display:flex;flex-direction:row;background:#efefef;padding: 1.2em 1.5em;">
  <span style="width:70px;font-size:2.8em">⚠️</span>
  <p style="flex:1;font-size:1.2em;line-height: 1.5;word-break: keep-all;">
    <span>이 블로그의 모든 포스트는 Notion 데이터베이스를 자동 변환하여 작성 되었습니다.</span><br />
    <span>따라서 문서에 따라 깨져 보일 수 있습니다.</span><br />
    <span>더 많은 내용이 궁금하시다면 👀</span> <a href="https://www.notion.so/croot-dev/6c50e956396b41449b42a8e134d97c4e" target="_blank" style="margin-top:12px;z-index:1">Notion 보러가기</a>
  </p>
</div>

</div>

<article class="c-article">
  <header class="c-article__header">
    <h1 class="c-article__title">Clean Archtecture 서적 정리</h1>
    <!-- <p class="c-article__time"><time datetime="2023-12-27T00:00:00+09:00" itemprop="datePublished">Dec 27, 2023</time></p> -->
  </header>

  <div class="c-article__info">
    <table>
      <tbody>
        <tr>
          <th>작성일</th><td>2023년 12월 27일</td>
        </tr>
        <tr>
          <th>수정일</th><td>2024년 08월 03일</td>
        </tr>
        <tr>
          <th>카테고리</th><td>취미</td>
        </tr>
        <tr>
          <th>태그</th><td>
            <ul class="c-tags">
              
            </ul>
          </td>
        </tr>
        
      </tbody>
    </table>
  </div>

  <div class="c-article__main">
    <h2 id="소개">소개</h2>

<h3 id="설계와-아키텍처의-차이">설계와 아키텍처의 차이</h3>

<p>설계(Design): 저수준의 구조 또는 결정사항 등을 의미</p>

<p>아키텍처(Architecture): 저수준의 세부사항과는 분리된 고수준의 무언가를 가리킬 때 사용하는 단어</p>

<h3 id="아키텍처-목표">아키텍처 목표</h3>

<p>필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하기 위함.</p>

<h2 id="가치">가치</h2>

<p>모든 소프트웨어 시스템은 이해관계자에게 <code class="language-plaintext highlighter-rouge">행위(behavior)</code> 와 <code class="language-plaintext highlighter-rouge">구조(structure)</code>를 제공한다.</p>

<p>소프트웨어는 유연하여야 한다. <em>(비복비복변순무)</em></p>

<p>변경사항 적용 어려움은 범위(scope)에 비례 해야하며 형태(shape)와는 관련이 없어야한다.</p>

<p>즉, 아키텍처는 형태에 독립적 이여야한다.</p>

<h3 id="기능과-아키텍처의-관계">기능과 아키텍처의 관계</h3>

<p>시스템은 완전성과 변경용이성이 모두 중요하다. <code class="language-plaintext highlighter-rouge">아이젠하워 매트릭스</code>에 따라 판단이 중요하다.</p>

<p><img src="/assets/img/2023-12-27-Clean-Archtecture-서적-정리.md/0.png" alt="0" /><em>Untitled.png</em></p>

<div class="callout" style="display:flex;width:100%;border-radius:4px;background:rgb(241,241,239);padding: 16px 16px 16px 12px;">
<div style="display:flex;align-items:center;justify-content:center;height:24px;width:24px;border-radius:0.25em;flex-shrink:0;">💡</div>
<div style="white-space:pre-wrap;word-break:break-word;caret-color:rgb(55, 53, 47);margin-left:8px;padding-left:2px;padding-right:2px;">현업은 주로 3번<i>(긴급하지만 중요하지 않은 일)</i>을 1번<i>(긴급하고 중요한 일)</i>으로 착각하는 실수를 저지른다. </div>
</div>

<h2 id="패러다임과-아키텍처-관심사">패러다임과 아키텍처 관심사</h2>

<p>패러다임: 구조적, 객체지향, 함수형</p>

<p>관심사: 함수, 컴포넌트 분리, 데이터 관리</p>

<h3 id="구조적-프로그래밍">구조적 프로그래밍</h3>

<p>제어흐름의 직접적인 전환에 적용되는 규칙</p>

<p>기능적 분해 최고의 실천법</p>

<p>반증 가능한 단위를 만들 수 있는 방법론</p>

<h3 id="객체지향-프로그래밍">객체지향 프로그래밍</h3>

<p>제어흐름의 간접적인 전환에 따르는 규칙</p>

<p>SOLID 설계 원칙을 기반함.</p>

<p>특징: <code class="language-plaintext highlighter-rouge">캡슐화</code>, <code class="language-plaintext highlighter-rouge">추상화</code>, <code class="language-plaintext highlighter-rouge">다형성</code>, <code class="language-plaintext highlighter-rouge">정보은닉</code>, <code class="language-plaintext highlighter-rouge">상속</code></p>

<p>다형성을 이용하여 코드 <code class="language-plaintext highlighter-rouge">의존성 역전</code>할 수 있다.</p>

<h3 id="함수형-프로그래밍">함수형 프로그래밍</h3>

<p>변수 할당에 관련된 규칙</p>

<p>람다(lambda) 계산법을 기반함.</p>

<p>가변성과 불변성의 접점, 관리</p>

<div class="callout" style="display:flex;width:100%;border-radius:4px;background:rgb(241,241,239);padding: 16px 16px 16px 12px;">
<div style="display:flex;align-items:center;justify-content:center;height:24px;width:24px;border-radius:0.25em;flex-shrink:0;">💡</div>
<div style="white-space:pre-wrap;word-break:break-word;caret-color:rgb(55, 53, 47);margin-left:8px;padding-left:2px;padding-right:2px;">소프트웨어는 순차, 분기, 반복, 참조 로 구성되며 이 핵심은 변하지 않는다.</div>
</div>

<h2 id="solid-설계-원칙">SOLID 설계 원칙</h2>

<h3 id="단일-책임-원칙-srp-single-reponsibility-principle">단일 책임 원칙 (SRP; Single Reponsibility Principle)</h3>

<p>콘웨이 법칙을 따름</p>

<p>메서드와 클래스 수준의 원칙</p>

<h3 id="개방-폐쇄-원칙-ocp-open-closed-principle">개방 폐쇄 원칙 (OCP; Open-Closed Principle)</h3>

<p>확장에는 개방적, 수정에는 폐쇄적</p>

<p>고수준 컴포넌트를 보호하는 형태의 의존성 계층 구조가 필요</p>

<h3 id="리스코프-치환-원칙-lsp-liskov-substitution-principle">리스코프 치환 원칙 (LSP; Liskov Substitution Principle)</h3>

<p>구성요소는 서로 치환이 가능해야한다.</p>

<p>아키텍처 수준까지 확장해야하며 위배 시 큰일(?)난다 ㅎㅎ</p>

<h3 id="인터페이스-분리-원칙-isp-interface-segregation-principle">인터페이스 분리 원칙 (ISP; Interface Segregation Principle)</h3>

<p>사용하지 않는 것에 의존하지 않는다.</p>

<h3 id="의존성-역전-원칙-dip-dependency-inversion-principle">의존성 역전 원칙 (DIP; Dependency Inversion Principle)</h3>

<p>고수준 정책 구현 코드는 저수준 구현 코드에 의존해서는 안된다.</p>

<p>클래스 단위 정책</p>

<h2 id="컴포넌트-응집도">컴포넌트 응집도</h2>

<h3 id="재사용릴리즈-동등-원칙-rep-reuserelease-equivalence-principle">재사용/릴리즈 동등 원칙 (REP; Reuse/Release Equivalence Principle)</h3>

<p>재사용 단위는 릴리즈 단위와 같다</p>

<h3 id="공통-폐쇄-원칙-ccp-common-closure-principle">공통 폐쇄 원칙 (CCP; Common Closure Principle)</h3>

<p>동일 시점에 동일 이유로 변경되는 것들은 묶고, 아닌 것들은 분리 할 것.</p>

<p>컴포넌트 수준의 SRP</p>

<h3 id="공통-재사용-원칙-crp-common-reuse-principle">공통 재사용 원칙 (CRP; Common Reuse Principle)</h3>

<p>필요하지 않은 것에 의존하지 말 것.</p>

<p>ISP의 포괄적인 버전</p>

<h3 id="균형-다이어그램">균형 다이어그램</h3>

<p>세 가지 원칙은 서로 상충 관계이며 <strong><code class="language-plaintext highlighter-rouge">REP, CCP 는 포함 원칙</code></strong>이며 <strong><code class="language-plaintext highlighter-rouge">CRP는 배재 원칙</code></strong>이다.</p>

<p><img src="/assets/img/2023-12-27-Clean-Archtecture-서적-정리.md/1.png" alt="1" /><em>Untitled.png</em></p>

<div class="callout" style="display:flex;width:100%;border-radius:4px;background:rgb(241,241,239);padding: 16px 16px 16px 12px;">
<div style="display:flex;align-items:center;justify-content:center;height:24px;width:24px;border-radius:0.25em;flex-shrink:0;">💡</div>
<div style="white-space:pre-wrap;word-break:break-word;caret-color:rgb(55, 53, 47);margin-left:8px;padding-left:2px;padding-right:2px;">프로젝트는 일반적으로 삼각형 오른쪽(CCP)에서 시작해서 다른 프로젝트가 시작되면 왼쪽(REP)으로 이동해간다.</div>
</div>

<h2 id="컴포넌트-결합">컴포넌트 결합</h2>

<h3 id="의존성-비순환-원칙-adp-acyclic-dependencies-principle">의존성 비순환 원칙 (ADP; Acyclic Dependencies Principle)</h3>

<p>순환 구조 시 <strong><code class="language-plaintext highlighter-rouge">숙취 증후군</code></strong> 문제 발생하며, <strong><code class="language-plaintext highlighter-rouge">Weekly Build</code></strong>와 <strong><code class="language-plaintext highlighter-rouge">순환 의존성 제거</code></strong> 를 통해 해결</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">Weekly Build</code></strong> : 통합 일정을 잡아 진행, 규모가 커질수록 비효율적</li>
  <li><strong><code class="language-plaintext highlighter-rouge">순환 의존성 제거</code></strong> : 의존 관계가 <strong><code class="language-plaintext highlighter-rouge">DAG(Direct Access Graph)</code></strong>이 되도록 하는 방법.
    <ul>
      <li>의존성 역전 원칙(DIP) 적용하여 해결</li>
      <li>의존하는 새로운 컴포넌트 생성</li>
      <li>컴포넌트 구조 변경(Jitter)을 항상 관찰</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong>숙취 증후군(morning after syndrome) :</strong> 의존하던 무언가를 누군가 수정하여 동작되지 않는 현상</p>
</blockquote>

<h3 id="안정된-의존성-원칙-sdp-stable-dependencies-principle">안정된 의존성 원칙 (SDP; Stable Dependencies Principle)</h3>

<p>더 안정된 방향으로 의존하라</p>

<ul>
  <li>
    <p><strong>안정성 지표</strong></p>

\[I = FanOut ÷ (FanIn + FanOut)\]

    <blockquote>
      <p>FanIn: 들어오는 의존성<br />
FanOut : 나가는 의존성</p>
    </blockquote>

    <p>계산 예시</p>

    <p><img src="/assets/img/2023-12-27-Clean-Archtecture-서적-정리.md/2.png" alt="2" /><em>Untitled.png</em></p>
  </li>
</ul>

<h3 id="안정된-추상화-원칙-sap-stable-abstractions-principle">안정된 추상화 원칙 (SAP; Stable Abstractions Principle)</h3>

<p>컴포넌트는 안정된 정도만큼만 추상화 되어야한다.</p>

<p>안정성과 추상화 정도 사이의 관계를 정의</p>

<ul>
  <li>
    <p><strong>추상화 정도</strong></p>

\[A = Na ÷ Nc\]

    <blockquote>
      <p>Na : 컴포넌트의 추상클래스와 인터페이스 개수<br />
Nc : 컴포넌트의 클래스 개수</p>
    </blockquote>
  </li>
  <li>
    <p><strong>A/I 그래프</strong></p>

    <p><img src="/assets/img/2023-12-27-Clean-Archtecture-서적-정리.md/3.png" alt="3" /><em>Untitled.png</em></p>

    <blockquote>
      <p><strong>배재구역</strong>(Zone of Exclusion)<strong>의 종류</strong></p>
      <ul>
        <li><strong>Zone of Pain :</strong> 안정적이며 구체적인 컴포넌트, 변동성이 있는 컴포넌트는 변경해야 한다.</li>
        <li><strong>Zone of Uselessness :</strong> 추상적이지만 의존이 없는 컴포넌트.</li>
      </ul>
    </blockquote>

    <div class="callout" style="display:flex;width:100%;border-radius:4px;background:rgb(241,241,239);padding: 16px 16px 16px 12px;">
  <div style="display:flex;align-items:center;justify-content:center;height:24px;width:24px;border-radius:0.25em;flex-shrink:0;">💡</div>
  <div style="white-space:pre-wrap;word-break:break-word;caret-color:rgb(55, 53, 47);margin-left:8px;padding-left:2px;padding-right:2px;">주계열(Main Sequence)에 가깝게 위치하는 컴포넌트가 가장 이상적이며,<br />주계열과의 거리를 계산하여 편차가 높은 컴포넌트는 재검토 및 재구성이 필요하다.</div>
  </div>
  </li>
</ul>

<h2 id="아키텍처">아키텍처</h2>

<h3 id="독립성">독립성</h3>

<p>서로 다른 업무 규칙은 분리하여 독립적으로 변경 되도록 해야한다.</p>

<p>좋은 아키텍처는 다음 네 가지 주요항목을 지원한다.</p>

<ul>
  <li><strong>UseCase</strong> :  시스템의 수평적 계층을 가로지르는 수직적으로 분리</li>
  <li><strong>운영</strong> : 요구사항 변경에 대응에 유연하다.</li>
  <li>
    <p>개발 : 컨웨이 법칙</p>

    <div class="callout" style="display:flex;width:100%;border-radius:4px;background:rgb(241,241,239);padding: 16px 16px 16px 12px;">
  <div style="display:flex;align-items:center;justify-content:center;height:24px;width:24px;border-radius:0.25em;flex-shrink:0;">💡</div>
  <div style="white-space:pre-wrap;word-break:break-word;caret-color:rgb(55, 53, 47);margin-left:8px;padding-left:2px;padding-right:2px;">Conway’s law : 프로젝트 조직은 조직의 의사소통 구조와 동일한 시스템 설계를 만든다.</div>
  </div>
  </li>
  <li>배포 : 즉시배포가 목표이며 UseCase를 유연하게 교체, 변경 할 수 있어야한다.</li>
</ul>

<p>결합 분리 수준 유형은 <code class="language-plaintext highlighter-rouge">소스 수준</code>, <code class="language-plaintext highlighter-rouge">배포 수준</code>, <code class="language-plaintext highlighter-rouge">서비스 수준</code> 으로 나뉠 수 있으며,</p>

<p>결합 분리는 선택사항으로 남기고 배포 규모에 따라 선택 사용 할 수 있게 해야한다.</p>

<h3 id="경계boundary">경계(Boundary)</h3>

<p>컴포넌트 분리 후 핵심 업무 규칙과 플러그인으로 구분</p>

<p>경계전략</p>


  </div>

  <div class="c-article__comment">
    <script src="https://utteranc.es/client.js"
        repo="croot-dev/croot-dev.github.io"
        issue-term="title"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
  </div>


  <!-- Previous / Next Buttons -->
  <div class="pagenav">
    
    <div class="wrapper" id="left">
      <small><b>Previous</b> Dec 21, 2023</small>
      <br>
      <a class="no-hov" href="/%EA%B8%B0%EC%88%A0/2023/12/21/Javascript-module-system-(CommonJS,-ES-Modules)/">&laquo; Javascript module system (CommonJS, ES Modules)</a>
    </div>
    
    
    <div class="wrapper" id="right">
      <small>Dec 29, 2023 <b>Next</b></small>
      <br>
      <a class="no-hov" href="/%EA%B8%B0%EC%88%A0/2023/12/29/JSON-Query-Libraries/">JSON Query Libraries &raquo;</a>
    </div>
    
  </div>
  <!-- Disqus comments view -->
  
</article>

  </div>
  <footer class="c-page__footer">
  <p>&copy; croot-dev.github.io 2026</p>
  <p><a href="https://github.com/croot-dev">Github</a></p>
</footer>

</div>

    </main>
    
  </body>
</html>
